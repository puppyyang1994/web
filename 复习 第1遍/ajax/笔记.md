2023-2-**9**

1. Ajax是什么？Ajax就是让浏览器跟服务器交互的一套API
    Ajax 是一种 用于向服务器请求数据的技术，是异步的Javascript和XML（Asynchronous JavaScript And XML)
    Ajax最吸引人的就是它的“异步”特性，也就是说可以在不重新刷新页面的情况下与服务器通信，交换数据 或更新页面

2. 学习目标？ 学会使用ajax根据接口文档和服务器交互
   目前 我们网页所有的数据都是写死的。实际开发中， 网页的数据需要从服务器获取，而ajax技术就是来实现这一功能


3. 如何学习？
   - 服务器了解  a 什么是服务器  b 服务器的交互流程
   - ajax工作流程
   - 可以使用ajax向服务器请求数据
   - ajax综合应用

**服务器**
1. 我们前端主要是是通过chrome来和服务器进行交互 
   - 前端访问服务器的几种方式：
2. 浏览器和服务器之间的每一次交互，都是由三个部分组成： 
   - 请求（浏览器发起请求，服务器接收）
   - 处理 （服务器处理这个请求）
   - 响应（服务器响应数据给浏览器）


### ajax工作流程
1. 创建XMLHttpRequest对象（俗称小黄人）
2. 设置请求
3. 发送请求
4. 注册回调函数 这个函数不是立即执行的，而是等服务器把数据响应返回才会执行（什么时候执行取决于你网速）


### axios框架
1. 什么是axios？一个JS框架 用于发送ajax请求（底层使用XMLHttprequest)
2. 为什么要学习axios？
   - 学习Vue的时候用axios发送ajax请求
   - 实际开发中也是用axios发送请求
   - Axios是一个基于promise的HTTP库，可以用在浏览器和node.js中
   
3. axios使用方法
   - 基本使用
     axios.get('url')
         .then(res=>{//请求成功})
         。catch(err=>{//请求失败})
         。then(()=>{//请求完成 无论成功还是失败})
   - axios发送get请求
     axios.get('url', {params:{key:valuie}})
     .then(res=>{//请求完成})

   - axios发送post请求
     axios.post('url', {key:value})
            .then(res=>{//请求完成})

   - 推荐用法
     axios({
      method:'请求方法',
      url:'请求路径',
      data:{post参数},
      params:{get参数},
     }).then(res=>{//请求成功})


     ### 链式语法

     ```
     // 链式语法：对象可以连续调用方法
        // 链式语法底层原理：在对象的方法中返回自身

        let obj = {
            name: 'ikun',
            sex: 'nan',
            age: 17
        }
        obj.setName = function (str) {
            this.name = str
            return this
        }
        obj.setAge = function (num) {
            this.age = num
            return this
        }
        obj.setSex = function (str) {
            this.sex = str
            return this
        }
        obj.setName('黑马').setAge(28).setSex('nv')
        console.log(obj);

### location页面跳转
1. location.href = 'url?id=参数值'
2. B页面拿到ID let id= location.search.split('=')
3. 然后把拿到的id 放到url里`url${id}`



**2023-2-10**
1. 机器人案例  
先引入了JQuery的UI，mousewheel和scroll插件
2. 切换栏案例


**2023-2-11**

### 图书综合管理系统
页面部分引入了bootstrap 栅格系统 表格 卡片 form 表单等组件
功能：
1. 数据渲染 renderData()渲染函数 独立封装 ; ajax请求也独立封装
2. 增删  
   增减：封装form表单获取参数函数（记得处理表单默认提交事件） 拿到参数后 发送post请求传给服务器 再重新获取图书列表 
    删除： 利用事件委托 因为td都是动态添加的 所以不能直接给他注册事件 但可以利用事件冒泡 给父元素注册事件 从而达到委托子元素来处理这个目的
    由于子元素有好多 所以首先要选出目标子元素 e.target.classList.contains(类名) 通过类名来判断 
    然后在动态渲染列表的时候给删除按钮添加了一个自定义的data-id属性 这个 通过e.target.getAttribute（data-id) 能拿到每次点击时的对应的属性值id 从而精准删除
3. loading效果实现  这个和前面的案例很像  先把样式做好 display:none  等需要的时候显示就好

事件委托 这个概念又忘了？
事件委托的核心原理是 不给每个子节点单独设置监听事件，而是事件监听器设置在父节点上，然后利用冒泡原理影响设置每个子节点 比如点击的是li 但是li会有冒泡事件 传给ul

**axios拦截器**
1. axios发起请求
2. 执行 请求拦截器  添加ajax发送请求之前的操作
3. 服务器 接收 处理 响应 请求、
4. 执行 相应拦截器 添加服务器响应之后的操作
5. axios 接收响应（执行then方法）

```
// 请求拦截器
// use(两个参数)
axios.interceptors.request.use(req => {
    // 在发送请求前要做的事儿
    ...
    return req
}, err => {
    // 在请求错误时要做的事儿
    ...
    // 该返回的数据则是axios.catch(err)中接收的数据
    return Promise.reject(err)
})
```

```
//响应拦截器
// use(两个参数)
axios.interceptors.reponse.use(res => {
    // 请求成功对响应数据做处理
    ...
    // 该返回的数据则是axios.then(res)中接收的数据
    return res
}, err => {
    // 在请求错误时要做的事儿
    ...
    // 该返回的数据则是axios.catch(err)中接收的数据
    return Promise.reject(err)
})
```

**axios全局基地址**  这样方便写接口

### 2023-2-12
1. 了解了ajax对象XMLHttpRequest对象的两个事件 onload 和 onreadystatechange
2. 进一步了解ajax的组成部分
    Ajax是 asynchronous Javascript and XML(异步JS和XML)  也就是用JS发送异步请求

    **什么是异步** 同步：按照顺序从上往下执行； 异步：不会立即执行 儿童是过一会儿执行
    ECMAScript只有两个语法是异步的 一个是 定时器 一个是ajax
    事件也是异步的，只是属于dom语法 一般讨论同步异步不包含事件
    **什么是XML** （与json完全一致，也是解决数据跨平台传输） 与 XMLHttpRequest
    ajax技术诞生的时候 json还没有流行 那
    个时候主要使用XML数据格式 但随着json的流行 xml逐渐被json所取代
    但是ajax的x 代表xml称呼保留至今



3. post 和 get的区别
   * 1.传参方式不同
  * get在url后面拼接(请求行)
  * post在请求体传参
* 2.大小限制不同
  * get有大小限制，不同浏览器大小限制不同。 一般2-5 MB
  * post没有大小限制
* 3.安全性不同
  * get参数直接暴露在url，不安全(一般查询类数据都是get)
  * post参数在请求体中，更加安全（一般登录注册必须是post）
* 4.传输速度不同
  * get传输速度快
  * post传输速度慢



### AJAX 工作原理 和 HTTP协议
https://www.jianshu.com/p/c93d47c26a81
1. 学习传送门 一个网站从输入网址URL到呈现页面完整的流程
    - DNS解析，将域名解析成IP地址
    - TCP连接：TCP三次握手
    - 发送HTTP请求
    - 服务器处理请求并返回http报文
    - 浏览器解析渲染页面
    - 断开连接 TCP四次挥手


2. 什么是URL？
   - url是Uniform Resource Locator 统一资源定位符 用于定位互联网上资源 俗称网址
   -  http://www.baidu.com/demo/index.html
   scheme://host.domain:port/path/filename
   scheme Internet协议的类型，常见有http https, ftp, file; 最常见的是http， https是进行加密的网络传输
   host 定义域主机（比如http的默认主机是www)
   domain 域名 比如 www.baidu.com
   port 主机上的端口号（http的默认端口号是80）
   path 服务器上的路径 （如果省略 则文档必须位于网站的根目录中）
   filename 定义文档/资源的名称


3. 域名解析（DNS）
   - 在浏览器输入网之后，首先要经过域名解析，因为浏览器不能通过域名直接找到对应的服务器， 而是IP地址。
   IP地址是指互联网协议地址，IP地址是IP地址协议提供的一种统一的地址格式, 它为互联网上的每个网格和每一台主机分配了一个逻辑地址, 以此来屏蔽物理地址的差异. IP地址是一个32位的二进制数, 比如: 127.0.0.1 为本机IP.
   域名的作用就是便于记忆和沟通的一组服务器地址. 用户通常使用主机名或域名来访问对方的计算机, 而不是直接通过IP地址访问. 因为与IP地址的一组纯数字相比, 用字母组合配合数字的表示形式来指定计算机名更符合人类的记忆习惯, 但要让计算机去理解名称, 相对而言就变得困难了. 因为计算机更擅长处理一长串数字. 为了解决上述问题, DNS服务应运而生.
  - DNS协议提供通过域名查找IP地址, 或逆向从IP地址反查域名的服务. DNS是一个网络服务器, 我们的域名解析简单来说就是在DNS上记录一条信息记录.
   ```
   例如 baidu.com 220.114.23.56（服务器外网IP地址）80（服务器端口号）
   ```

4. 浏览器如何通过域名去查询URL对应的IP?
浏览器缓存: 浏览器会按照一定的频率缓存DNS记录.
操作系统缓存: 如果浏览器缓存中没有找到需要的DN记录, 就会去操作系统中查找
路由缓存: 路由器也有DNS缓存
ISP的DNS服务器: ISP 是互联网服务提供商(Internet Service Provider)的简称，ISP 有专门的 DNS 服务器应对 DNS 查询请求。
根服务器: ISP 的 DNS 服务器还找不到的话，它就会向根服务器发出请求，进行递归查询（DNS 服务器先问根域名服务器.com 域名服务器的 IP 地址，然后再问.baidu 域名服务器，依次类推）
浏览器通过向DNS服务器发送域名, DNS服务器查询到与域名相对应的IP地址, 然后返回给浏览器, 浏览器再将IP地址打在协议上, 同时请求参数也会在协议中搭载, 然后一并发送给对应原服务器.

5. 在客户端发送数据之前会发起TCP三次握手, 用以同步客户端和服务端的序列号和确认号, 并交换TCP报文信息.

6. 发送http请求
   TCP三次握手结束后, 开始发送HTTP请求报文

请求报文由请求行(request line), 请求头(request header), 请求体(request body)三大部分组成, 如下图所示


7. 简单梳理 一个页面从输入URL到页面呈现的完整过程
- DNS域名解析：将URL中的域名解析成IP地址
- TCP三次握手 建议安全的网络传输协议
 - - 什么是TCP 一种 传输控制协议
 - - TCP的作用：保证HTTP网络传输是安全+可靠的（检测客户端与服务器端的网卡是不是通的）
 - - TCP的三次握手：
   - - 第一次： 浏览器- 服务器  （你能听到我说话吗）检测浏览器 发送
   - - 第二次 服务器- 浏览器 （我听到了 你能听到我说话吗）检测服务器 接收+发射
   - - 第三次 浏览器- 服务器 （我听到了） 检测浏览器 接收
- HTTP建立连接
   - 客户端发送请求
   - 服务器处理请求
   - 服务器响应请求
 - 渲染引擎开始渲染响应返回的HTML文本
   - 解析html生成 dom树
   - 解析css 生成 样式树
   - dom树和样式树 合并成渲染树
   - 呈现页面


### 文件上传
文件上传必须要FormData对象：因为文件数据和文本数据 在传输的时候 数据格式不一样， 此时需要FormData对象进行自动处理

1. 前置知识点：
1.1 file表单 默认自带点击事件 作用是选择文件
1.2 上传文件必须要使用原生内置的FormData对象
    - 文件需要设置单独的请求头 miltipart/form-data
    - 文件已二进制方式传输（文本是utf8编码 但是文件不是）
1.3 file表单有一个特殊的onchange事件：用户选择了文件就会执行

2. 文件上传流程
2.1 在file表单的onchange事件中获取用户选择的图片 this.files[0]
2.2 创建FormData对象 将图片添加到fd对象中 let fd = new FormaData() fd.append('接口参数', 文件数据)
2.3 ajax发送请求：参数必须是formdata对象

* 注意区别 dom元素.click() 和dom元素.onclick()  前者可以触发注册事件和默认点击事件(a标签 form按钮 file表单 )  后者只能触发注册事件
 

### 综合案例 英雄管理  （这个案例挺综合的 值得多敲几遍）

这里主要涉及到几个：
- 渲染页面  这个没有什么问题
- 搜索  这里注意e.key 的使用 然后重新发送ajax的get请求 里面的参数是 params:{query:this.value}
- 文件上传  这个是重点  首先是给file表单 添加onchange事件 获取到用户选择的图片 然后利用 URL.createObjectURL(file) 把file对象转换为url   再把url给 img的src  所以 img只是用来呈现图片的  真正用来选择文件的还是input标签
  
  - 然后是上传文件 还是那几步  给新增按钮注册点击事件后 记得首先要阻止表单默认提交  然后创建FormData对象 然后给对象添加参数 利用 fd.append(参数名：参数值)，这里要注意参数值是提取input.value  头像是提取file文件的第一张图； 然后发起ajax请求  （让页面跳转到首页 利用location.href)


**2023-2-13**
### 函数节流和防抖  
函数防抖和节流：优化高频率执行JS代码的一种手段，JS中的事件 如resize, scroll,mousemove, mouseover, input输入框的keypress等事件在触发时，会不断地调用绑定在事件上的回调函数，极大浪费资源，降低前端性能。为了优化体验，需要对函数调用的次数进行限制。
1. 什么是防抖？ 单位时间内 频繁触发一个事件，以最后一次触发为准
- 用大白话来说就是 **防抖就是要延迟执行，你一直操作触发事件一直不执行，当你停止操作等待多少秒后才执行。**
- 防抖应用场景：输入框事件
-  防抖流程: 1. 声明一个全局变量存储定时器ID  2.每一次触发交互的时候，先清除上一次定时器，然后把本次事件处理代码放入到定时器中


2. 函数节流 一节一节的流，就好似控制水阀，在事件不断触发的过程中，固定时间内执行一次事件。

https://segmentfault.com/a/1190000018445196
https://www.51cto.com/article/705457.html
https://shawnzhou.world/2022/02/18/debounce-and-throttle/
异同比较
相同点：

都可以通过使用 setTimeout 实现。
目的都是，降低回调执行频率。节省计算资源。
不同点：
函数防抖，在一段连续操作结束后，处理回调，利用clearTimeout 和 setTimeout实现。函数节流，在一段连续操作中，每一段时间只执行一次，频率较高的事件中使用来提高性能。
函数防抖关注一定时间连续触发的事件只在最后执行一次，而函数节流侧重于一段时间内只执行一次。

常见应用场景
函数防抖的应用场景
连续的事件，只需触发一次回调的场景有：

搜索框搜索输入。只需用户最后一次输入完，再发送请求
手机号、邮箱验证输入检测
窗口大小Resize。只需窗口调整完成后，计算窗口大小。防止重复渲染。
函数节流的应用场景
间隔一段时间执行一次回调的场景有：

滚动加载，加载更多或滚到底部监听
谷歌搜索框，搜索联想功能
高频点击提交，表单重复提交