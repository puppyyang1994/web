<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>

<body>
    <script>
        // call 和 apply都是为了改变函数体内部this指向而存在的
        function fruits() { }
        fruits.prototype = {
            color: 'red',
            say: function () {
                console.log('My color is ' + this.color);
            }
        }
        let apple = new fruits;
        apple.say();
        banana = {
            color: 'yellow'
        }
        apple.say.call(banana); // My color is yellow
        apple.say.apply(banana) //My color is yellow
        // call 和 apply 是为了动态改变this而存在的， 当一个对象没有某个方法 比如banana没有say方法
        // 但是apple有 所以可以用call 和 apply来操作其他对象的方法

        // call 和 apply的作用完全一样 只是接受参数的方式不一样
        let func = function (arg1, arg2) {

        };

        func.call(this, arg1, arg2)
        func.apply(this, [arg1, arg2])
        // this 可以是任何一个对象（你想this指向的那个对象）， call需要把参数按顺序传递进去，而
        //apply是把参数放在数组里
        // 一些实际例子
        // 数组之间的追加
        let arr1 = [12, 'foo', { name: 'Joe' }, -2345]
        let arr2 = ['Does', 555, 10]
        Array.prototype.push.apply(arr1, arr2)
        // arr1的值为[12, 'foo', { name: 'Joe' }, -2345,'Does', 555, 10]
        // 获取数组中的最大值最小值
        let numbers = [5, 458, 120, -124]
        let maxN = Math.max.apply(Math, numbers),
            minN = Math.max.call(Math, 5, 458, 120, -124)
    </script>
</body>

</html>