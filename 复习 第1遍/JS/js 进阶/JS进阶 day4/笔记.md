2023-2-8 JS高级内容部分笔记

## 浅拷贝和深拷贝
- 浅拷贝和深拷贝只针对引用类型
- 
1. 浅拷贝 拷贝的是地址
    - 常见方法：
      - 拷贝对象 Object.assgin()//展开运算符 {...obj}拷贝对象   
      - 拷贝数组 Array.prototype.concat() 或者 [...arr]
- 浅拷贝只是创建了一个新的对象，复制了原有对象的基本类型的值 而引用数据类型只拷贝了一层属性 在深层的还是无法进行拷贝
- 原理：自己创建一个新的对象，来接受你要重新复制或引用的对象值。如果对象属性是基本的数据类型，复制的就是基本类型的值给新对象，但如果属性是引用数据类型，复制的就是内存中的地址，如果其中一个对象改变了这个内存中的地址，肯定会影响到另一个对象


2. 深拷贝 拷贝的是对象 不是地址
  深拷贝 对于复杂引用数据类型 其在堆内存中完全开辟了一块内存地址， 并将原有的对象完全复制过来。这两个对象是相互独立的，不受影响，彻底实现了内存上的分离：
  原理：讲一个对象从内存中完整地拷贝出来一份给目标对象，并从堆内存中开辟一个全新的空间存放新对象，且新对象的修改并不会改变原对象，真正实现二者的分离

  - 常见方法：
    - 通过递归实现深拷贝
    - lodash/cloneDeep  引入JS库lodash实现
    - 通过JSON.stringify()实现  

```
 // 原生JSON.stringify() 把一个对象序列化为JSON字符串，并将对象里面的内容转化成字符串，最后再用
        // JSON.parse()的方法将JSON字符串生成一个新的对象

        let obj1 = { a: 1, b: [1, 2, 3] }
        // 把对象变成字符串
        let str = JSON.stringify(obj1)
        console.log(str);// { "a": 1, "b": [1, 2, 3] }
        // 把字符串变成对象
        let obj2 = JSON.parse(str)
        console.log(obj2);
        obj1.a = 2
        obj2.b.push(4)
        console.log(obj1);// {a: 2, b:[1,2,3]}
        console.log(obj2);// {a:1, b:[1,2,3,4]}
```
```
 //递归拷贝  
  const obj = {
            uname: 'pink',
            age: 18,
            hobby: ['乒乓', '足球'],
            family: {
                babay: 'little pink'
            }
        }

        const o = {}
        // 拷贝函数
        function deepCopy(newObj, oldObj) {
            // 用于停止执行JS，并调用调试函数
            // debugger
            for (let k in oldObj) {
                // 处理数组的问题 一定要先写数组 再写对象
                if (oldObj[k] instanceof Array) {
                    newObj[k] = []
                    deepCopy(newObj[k] = oldObj[k])
                } else if (oldObj[k] instanceof Object) {
                    newObj[k] = {}
                    deepCopy(newObj[k], oldObj[k])
                } else {
                    newObj[k] = oldObj[k]
                }
            }
        }

        deepCopy(o, obj)
        console.log(o);
        o.age = 20
        o.hobby[0] = '篮球'
        o.family.baby = '老'
        console.log(o);
        console.log(obj);
```
```
//lodash/cloneDeep  引入JS库lodash实现
 const obj = {
            uanme: 'pink',
            age: 18,
            hobby: ['乒乓', '足球'],
            family: {
                babay: 'little pink'
            }

        }
        const o = _.cloneDeep(obj)
        console.log(o);
        o.family.babay = 'laopink'
        console.log(obj);
```


#### 异常处理
- throw 抛异常
- try/catch 捕获异常
- debugger

1. throw抛异常
异常处理是指预估代码执行过程中可能发生的错误，然后最大程度的避免错误的发生导致整个程序无法继续进行（也就是说 在运行时发生的问题无法得到有意义的处理，最好抛出它）
```
 // throw 抛出异常信息，程序会中止
        function counter(x, y) {
            if (!x || !y) {
                // throw后面跟的是错误提示信息
                throw new Error('参数不能为空')
            }
            return x + y
        }
        counter()
        // Error对象配合throw使用，能够设置更详细的错误信息
```

2. 捕获异常 try/catch
3. debugger


### this指向问题
1. 普通函数中的this 
   - 默认绑定 函数独立调用 不涉及其他绑定规则 非严格模式下 this指向window，严格模式下指向undefined

```
//  普通函数 谁调用我 this就指向谁

        console.log(this);//window

        function f() {
            console.log(this);
        }
        f() //window

        window.setTimeout(function () {
            console.log(this);
        }, 1000) //window


        // 
        document.querySelector('button').addEventListener('click', function () {
            console.log(this); //指向button
        })

        const obj = {
            sayHi: function () {
                console.log(this); //指向对象obj
            }
        }
        obj.sayHi()


```
2. 箭头函数中的this
```
 // 2. 箭头函数中的this与普通函数完全不一样也不受调用方式的影响，事实上箭头函数中并不存在this
        // 箭头函数会默认帮我们绑定外层this的值，所以箭头函数中的this的值和外层函数this的值是一样的
        // 向外层作用域中，一层一层查找this,知道有this的定义

        console.log(this);//window
        const sayHi = function () {
            console.log(this);
        }
        sayHi() //window

        const user = {
            name: '小明',
            walk: () => {
                console.log(this);
            }
        }
        user.walk() //window
```
   - 注意情况1
```
        // 事件回调函数使用箭头函数时，this指向window，所以再DOM事件回调函数
        // 如果里面需要DOM对象this， 则不推荐使用箭头函数
        const btn = document.querySelector('button')
        // btn.addEventListener('click', () => {
        //     console.log(this); //此时指向的是window
        // })

        // 写成普通函数 此时指向DOM对象
        btn.addEventListener('click', function () {
            console.log(this);
        })
```

- 注意情况2 基于原型的面向对象也不推荐采用箭头函数
```
        function Person() {

        }
        Person.prototype.walk = () => {
            console.log('人都要走路的');
            console.log(this); //指向window
        }
        const p1 = new Person()
        p1.walk()


        // 总结 箭头函数不适用于 构造函数 圆形函数 DOM事件函数等

        // 适用于 需要使用上层this的地方

```

### 改变this指向问题
有三个方法可以动态指定普通函数中this的指向 
- call()
- apply()
- bind()
  
```
  // call(thisArg, arg1, arg2)使用call 
        // thisArg 在函数运行时指定的this值
        // arg1 arg2 传递的其他参数
        // 返回值就是函数的返回值 因为它就是调用函数
        const obj = {
            uname: 'pink'
        }
        function fn(x, y) {
            console.log(this);//本来是指向window的 但使用call之后就指向了指定的obj对象了
            console.log(x + y);
        }
        fn.call(obj, 1, 2)
        // 总结call的作用就是 调用函数 并且改变被调用函数里边的this
```
```
// 2 apply(thisArg, [数组参数])
        fn.apply(obj, [1, 2])

        // 3. 返回值 本身就是在调用函数 所以返回值就是函数的返回值
        // 使用场景 求数组最大值
        /* const max = Math.max(1, 2, 3)
        console.log(max); */

        const arr = [100, 44, 77]
        const max = Math.max.apply(Math, arr)
        const min = Math.min.apply(null, arr)
        console.log(max, min); //100 44
        // 利用展开运算符
        console.log(Math.max(...arr));

        // 总结：call 和 apply 都是能调用函数 改变this指向 但apply的参数必须是数组
```
```
// bind() 不会直接调用函数 但是可以改变函数内部的this指向 应用很广泛

        const obj2 = {
            age: 18
        }
        function fn2() {
            console.log(this);//obj2{}
        }

        // bind不会调用函数 但能改变this指向 返回值是个函数(改造后的原函数拷贝)  但是这个函数里面的this 是更改过的Obj2
        const fun = fn2.bind(obj2)
        console.log(fun);
        fun()
```
### 性能优化之节流和防抖
1. 节流 throttle
   连续触发事件但是在n秒钟只执行一次函数
   使用场景：
   小米轮播图点击效果 、 鼠标移动、页面尺寸缩放resize、滚动条滚动 就可以加节流。假如一张轮播图完成切换需要300ms， 不加节流效果，快速点击，则嗖嗖嗖的切换。加上节流效果， 不管快速点击多少次， 300ms时间内，只能切换一张图片。
2. 防抖 debounce
   触发事件后在n秒内函数只能执行一次，如果在n秒内有触发了事件，则会重新计算函数执行的时间
   使用场景：搜索框防抖
   假设输入就可以发送请求，但是不能每次输入都去发送请求，输入比较快发送请求会比较多
我们设定一个时间，假如300ms， 当输入第一个字符时候，300ms后发送请求，但是在200ms的时候又输入了一个字符，
则需要再等300ms 后发送请求

3. lodash库 实现节流和防抖
```
<div class="box"></div>
    <script src="./lodash.min.js"></script>
    <script>
        const box = document.querySelector('.box')
        let i = 1

        function mouseMove() {
            box.innerHTML = ++i
        }

        // lodash节流写法
        box.addEventListener('mousemove', _.throttle(mouseMove, 500))
        // lodash 防抖写法
        box.addEventListener('mousemove', _.debounce(mouseMove, 500))
    </script>
```

### 节流综合案例
